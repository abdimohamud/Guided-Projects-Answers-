Here's the implementation we wrote for the build_tree_from_preorder_and_inorder problem:
The idea is to start with the root node in the preorder list, then find the root node in the inorder list. In the inorder list, the root node's left subtree consists of all the elements to its left; the root node's right subtree consists of all the elements to its right. So this implementation recursively splits the tree over and over, constructing the subtree by picking the element located at the preorder_index, finding that element in the inorder list, and splitting the contents of the inorder list around that element in order to determine and construct its left and right subtrees.
The base case is when we've narrowed the in order list down to nothing, represented by the if inorder_start > inorder_end: check. Since we're always recursing into the left subtree first, this implementation always builds up the left subtree first, then works on the right subtree. So on each recursive call that builds up the left subtree, the preorder_index is being updated on every call until we finally start building the first subtree, where at the point, the preorder_index has been incremented multiple times from all the recursive calls that built up the left subtrees.